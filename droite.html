<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Droite Interactive Mario</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --mario-sky: #6b8cff;
            --mario-ground: #c45c16;
            --mario-brick: #b64b12;
            --text-color: #ffffff;
            --highlight: #fbd000; /* Coin yellow */
            --snap-color: #00ff00; /* Green shell */
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--mario-sky);
            font-family: 'Press Start 2P', cursive;
            overflow: hidden; /* Prevent scrolling */
            touch-action: none; /* Prevent standard touch actions */
            display: flex;
            flex-direction: column;
            height: 100vh;
            color: var(--text-color);
        }

        #canvas-container {
            flex-grow: 1;
            position: relative;
            background-image:
                linear-gradient(transparent 95%, rgba(255,255,255,0.2) 95%),
                linear-gradient(90deg, transparent 95%, rgba(255,255,255,0.2) 95%);
            background-size: 20px 20px;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #controls {
            flex-shrink: 0;
            background-color: var(--mario-ground);
            border-top: 4px solid #000;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            box-shadow: inset 0 4px 0 rgba(255,255,255,0.2);
        }

        #info-display {
            background-color: #000;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
            font-size: 12px;
            border: 2px solid #fff;
            line-height: 1.5;
        }

        .inputs-row {
            display: flex;
            justify-content: space-around;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .mario-btn {
            background-color: #e52521;
            border: 2px solid #000;
            color: white;
            font-family: 'Press Start 2P', cursive;
            font-size: 20px;
            width: 48px;
            height: 48px;
            cursor: pointer;
            box-shadow: 2px 2px 0 #8b1614;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }

        .mario-btn:active {
            transform: translate(2px, 2px);
            box-shadow: none;
        }

        .label-text {
            text-shadow: 2px 2px 0 #000;
        }

        /* Snapped state styling */
        .snapped-text {
            color: var(--snap-color) !important;
        }
    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="graphCanvas"></canvas>
    </div>

    <div id="controls">
        <div id="info-display">M = A + (0.0, 0.0) * u</div>

        <div class="inputs-row">
            <div class="control-group">
                <span class="label-text">tx</span>
                <button class="mario-btn" id="tx-minus">-</button>
                <button class="mario-btn" id="tx-plus">+</button>
            </div>

            <div class="control-group">
                <span class="label-text">ty</span>
                <button class="mario-btn" id="ty-minus">-</button>
                <button class="mario-btn" id="ty-plus">+</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        const infoDisplay = document.getElementById('info-display');

        // State
        let width, height;

        // Points (in screen coordinates)
        let A = { x: 0, y: 0 };
        let B = { x: 0, y: 0 };

        // M state (in terms of tx, ty)
        let M_params = { tx: 0.5, ty: 0.5 };

        const SNAP_THRESHOLD = 0.15;
        let isSnapped = false;

        // Initialization
        function resize() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            width = canvas.width;
            height = canvas.height;

            // Set A and B fixed positions (closer to center now, ~35% and 65% width)
            A = { x: width * 0.35, y: height * 0.55 };
            B = { x: width * 0.65, y: height * 0.45 };

            draw();
        }

        window.addEventListener('resize', resize);

        // Math Helpers
        function getVector(p1, p2) {
            return { x: p2.x - p1.x, y: p2.y - p1.y };
        }

        function getPointFromParams(tx, ty) {
            const u = getVector(A, B);
            // User Formula: Mx = Ax + tx*(Bx - Ax), My = Ay + ty*(By - Ay)
            return {
                x: A.x + tx * u.x,
                y: A.y + ty * u.y
            };
        }

        function getParamsFromPoint(x, y) {
            const u = getVector(A, B);
            // Inverse: tx = (Mx - Ax) / ux, ty = (My - Ay) / uy
            // Avoid division by zero
            const tx = Math.abs(u.x) > 0.001 ? (x - A.x) / u.x : 0;
            const ty = Math.abs(u.y) > 0.001 ? (y - A.y) / u.y : 0;
            return { tx, ty };
        }

        function updateDisplay(M_coords) {
            // Snap logic is handled in draw() or input handler
            // Just display current values
            const dispTx = M_params.tx.toFixed(2);
            const dispTy = M_params.ty.toFixed(2);

            let html = `Mx = Ax + <span style="color:#00ffff">${dispTx}</span> * (Bx - Ax)<br>`;
            html += `My = Ay + <span style="color:#ff00ff">${dispTy}</span> * (By - Ay)`;

            if (isSnapped) {
                html += '<br><span style="color:#00ff00; font-size:10px">ON THE LINE!</span>';
                infoDisplay.style.borderColor = "#00ff00";
            } else {
                infoDisplay.style.borderColor = "#fff";
            }
            infoDisplay.innerHTML = html;
        }

        function drawStats(M) {
            ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
            ctx.fillRect(10, 10, 220, 100);
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 2;
            ctx.strokeRect(10, 10, 220, 100);

            ctx.font = "12px 'Press Start 2P'";
            ctx.fillStyle = "#fff";
            ctx.textAlign = "left";

            const coords = [
                { label: "A", p: A, color: "#e52521" },
                { label: "B", p: B, color: "#e52521" },
                { label: "M", p: M, color: isSnapped ? "#00ff00" : "#fbd000" }
            ];

            coords.forEach((item, index) => {
                ctx.fillStyle = item.color;
                ctx.fillText(`${item.label} = (${Math.round(item.p.x)}, ${Math.round(item.p.y)})`, 20, 40 + index * 25);
            });
        }

        function draw() {
            // Background already handled by CSS, but let's clear
            ctx.clearRect(0, 0, width, height);

            // Draw Line AB
            ctx.save();
            ctx.beginPath();
            // Calculate far points
            const u = getVector(A, B);
            const slope = u.y / u.x;
            // Draw a long line
            ctx.strokeStyle = isSnapped ? "#00ff00" : "#ffffff";
            ctx.lineWidth = isSnapped ? 6 : 4;

            // Draw segment AB
            ctx.moveTo(A.x - u.x * 10, A.y - u.y * 10);
            ctx.lineTo(B.x + u.x * 10, B.y + u.y * 10);
            ctx.stroke();
            ctx.restore();

            // Draw A and B
            drawPoint(A, "A", "#e52521");
            drawPoint(B, "B", "#e52521");

            const uVec = getVector(A, B);

            // Snap Logic (Geometric distance to line)
            // Project current M (from params) to line
            let rawM = getPointFromParams(M_params.tx, M_params.ty);

            // Distance from rawM to line AB
            // Area of triangle = 0.5 * base * height
            // height = 2 * Area / base
            // Area = |(Bx-Ax)(Ay-My) - (Ax-Mx)(By-Ay)| / 2
            const num = Math.abs(uVec.x * (A.y - rawM.y) - (A.x - rawM.x) * uVec.y);
            const den = Math.sqrt(uVec.x**2 + uVec.y**2);
            const dist = num / den;

            isSnapped = dist < 20; // 20 pixels threshold

            let M = rawM;
            if (isSnapped) {
                // Project M onto line
                // P = A + t * u
                // t = (AM . u) / (u . u)
                const t = ((rawM.x - A.x) * uVec.x + (rawM.y - A.y) * uVec.y) / (uVec.x**2 + uVec.y**2);
                M = {
                    x: A.x + t * uVec.x,
                    y: A.y + t * uVec.y
                };
            }

            const displayParams = getParamsFromPoint(M.x, M.y);

            // Draw Vectors
            // Draw AM
            drawArrow(A, M, "#ffffff", 2);

            // Draw Projections
            drawProjection(A, "A", "#e52521");
            drawProjection(B, "B", "#e52521");
            drawProjection(M, "M", isSnapped ? "#00ff00" : "#fbd000");

            // Draw M
            drawPoint(M, "M", isSnapped ? "#00ff00" : "#fbd000", true);

            // Override display with snapped values if snapped
            const originalParams = M_params;
            M_params = displayParams;
            updateDisplay(M);
            M_params = originalParams;

            drawStats(M);
            drawStats(M);
        }

        function drawProjection(p, label, color) {
            ctx.save();
            ctx.setLineDash([2, 2]);
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;

            // Project to X axis (Top edge)
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x, 0);
            ctx.stroke();

            // Label X
            ctx.fillStyle = color;
            ctx.font = "10px 'Press Start 2P'";
            ctx.fillText(label + "x", p.x - 10, 12);

            // Project to Y axis (Left edge)
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(0, p.y);
            ctx.stroke();

            // Label Y
            ctx.fillText(label + "y", 2, p.y - 5);

            ctx.restore();
        }

        function drawArrow(from, to, color, width) {
            const headlen = 10; // length of head in pixels
            const angle = Math.atan2(to.y - from.y, to.x - from.x);

            ctx.save();
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = width;

            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.stroke();

            // Arrowhead
            ctx.beginPath();
            ctx.moveTo(to.x, to.y);
            ctx.lineTo(to.x - headlen * Math.cos(angle - Math.PI / 6), to.y - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(to.x - headlen * Math.cos(angle + Math.PI / 6), to.y - headlen * Math.sin(angle + Math.PI / 6));
            ctx.lineTo(to.x, to.y);
            ctx.fill();
            ctx.restore();
        }

        function drawLabel(x, y, text, color) {
            ctx.save();
            ctx.font = "10px 'Press Start 2P'";
            ctx.fillStyle = color;
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2;
            ctx.strokeText(text, x + 5, y - 5);
            ctx.fillText(text, x + 5, y - 5);
            ctx.restore();
        }

        function drawPoint(p, label, color, isM = false) {
            ctx.fillStyle = color;
            const size = isM ? 12 : 8;

            // Pixel art point (square)
            ctx.fillRect(p.x - size/2, p.y - size/2, size, size);

            // Outline
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;
            ctx.strokeRect(p.x - size/2, p.y - size/2, size, size);

            // Label
            ctx.font = "16px 'Press Start 2P'";
            ctx.fillStyle = "#fff";
            ctx.strokeStyle = "black";
            ctx.lineWidth = 3;
            ctx.strokeText(label, p.x + 15, p.y - 15);
            ctx.fillText(label, p.x + 15, p.y - 15);
        }

        // Interaction
        function handleInput(x, y) {
            // Check snap distance
            const uVec = getVector(A, B);
            const num = Math.abs(uVec.x * (A.y - y) - (A.x - x) * uVec.y);
            const den = Math.sqrt(uVec.x**2 + uVec.y**2);
            const dist = num / den;

            let params = getParamsFromPoint(x, y);

            if (dist < 20) {
                // Snap to line implies tx = ty
                // Find projection t
                const t = ((x - A.x) * uVec.x + (y - A.y) * uVec.y) / (uVec.x**2 + uVec.y**2);
                params = { tx: t, ty: t };
            }

            M_params = params;
            draw();
        }

        // Pointer Events (Mouse + Touch)
        let isDragging = false;

        function onPointerDown(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || e.touches[0].clientX) - rect.left;
            const y = (e.clientY || e.touches[0].clientY) - rect.top;

            // Check if clicking near M (optional, or allow clicking anywhere to move M)
            // Let's allow clicking anywhere to teleport M, it's easier for mobile
            isDragging = true;
            handleInput(x, y);
        }

        function onPointerMove(e) {
            if (!isDragging) return;
            e.preventDefault(); // Prevent scrolling
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || e.touches[0].clientX) - rect.left;
            const y = (e.clientY || e.touches[0].clientY) - rect.top;
            handleInput(x, y);
        }

        function onPointerUp() {
            isDragging = false;
            if (isSnapped) {
                // If released while snapped, keep the snapped state
                // The current M_params (calculated in handleInput) are already correct (tx=ty)
                draw();
            }
        }

        canvas.addEventListener('mousedown', onPointerDown);
        canvas.addEventListener('mousemove', onPointerMove);
        window.addEventListener('mouseup', onPointerUp);

        canvas.addEventListener('touchstart', onPointerDown, {passive: false});
        canvas.addEventListener('touchmove', onPointerMove, {passive: false});
        window.addEventListener('touchend', onPointerUp);

        // Buttons
        function adjust(param, delta) {
            M_params[param] += delta;
            // Round to avoid float errors
            M_params[param] = Math.round(M_params[param] * 10) / 10;
            draw();
        }

        document.getElementById('tx-minus').addEventListener('click', () => adjust('tx', -0.1));
        document.getElementById('tx-plus').addEventListener('click', () => adjust('tx', 0.1));
        document.getElementById('ty-minus').addEventListener('click', () => adjust('ty', -0.1));
        document.getElementById('ty-plus').addEventListener('click', () => adjust('ty', 0.1));

        // Start
        setTimeout(resize, 100); // Small delay to ensure layout is ready
    </script>
</body>
</html>
