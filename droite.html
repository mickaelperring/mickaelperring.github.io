<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Droite Interactive - Taylor's Version</title>
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Taylor Swift "Lover" / "Eras" Palette */
            --ts-bg-gradient: linear-gradient(135deg, #fbc2eb 0%, #a6c1ee 100%); /* Pink to Blue */
            --ts-panel-bg: rgba(255, 255, 255, 0.4);
            --ts-text: #4a4a4a;
            --ts-accent-gold: #d4af37;
            --ts-accent-rose: #e08e9d;
            --ts-accent-lavender: #b39cd0;
            --ts-snap: #50c878; /* Emerald Green (Rep/Debut) or just bright green for snap */
            --ts-snap-glow: #00ff00;
        }

        body {
            margin: 0;
            padding: 0;
            background: var(--ts-bg-gradient);
            font-family: 'Lato', sans-serif;
            overflow: hidden;
            touch-action: none;
            display: flex;
            flex-direction: column;
            height: 100vh;
            color: var(--ts-text);
        }

        #canvas-container {
            flex-grow: 1;
            position: relative;
            /* Subtle sparkle/grid overlay? Let's keep it clean or soft grid */
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.3) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.3) 1px, transparent 1px);
            background-size: 40px 40px;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #controls {
            flex-shrink: 0;
            background-color: var(--ts-panel-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255,255,255,0.5);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-shadow: 0 -4px 20px rgba(0,0,0,0.05);
        }

        #info-display {
            background-color: rgba(255, 255, 255, 0.6);
            padding: 12px;
            border-radius: 12px;
            text-align: center;
            font-size: 14px;
            border: 1px solid rgba(255,255,255,0.8);
            line-height: 1.6;
            font-family: 'Playfair Display', serif;
            color: #333;
            box-shadow: inset 0 2px 5px rgba(255,255,255,0.5);
            transition: all 0.3s ease;
        }

        .inputs-row {
            display: flex;
            justify-content: space-around;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(255,255,255,0.3);
            padding: 8px 15px;
            border-radius: 30px;
        }

        .ts-btn {
            background: linear-gradient(135deg, #ffd1ff 0%, #fad0c4 100%);
            border: none;
            color: #555;
            font-family: 'Playfair Display', serif;
            font-weight: 700;
            font-size: 18px;
            width: 44px;
            height: 44px;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .ts-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .label-text {
            font-family: 'Playfair Display', serif;
            font-style: italic;
            font-size: 18px;
            color: #555;
        }
    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="graphCanvas"></canvas>
    </div>

    <div id="controls">
        <div id="info-display">Mx = Ax + 0.0 * (Bx - Ax)<br>My = Ay + 0.0 * (By - Ay)</div>

        <div class="inputs-row">
            <div class="control-group">
                <span class="label-text">tx</span>
                <button class="ts-btn" id="tx-minus">-</button>
                <button class="ts-btn" id="tx-plus">+</button>
            </div>

            <div class="control-group">
                <span class="label-text">ty</span>
                <button class="ts-btn" id="ty-minus">-</button>
                <button class="ts-btn" id="ty-plus">+</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        const infoDisplay = document.getElementById('info-display');

        // State
        let width, height;

        // Points (in screen coordinates)
        let A = { x: 0, y: 0 };
        let B = { x: 0, y: 0 };

        // M state (in terms of tx, ty)
        let M_params = { tx: 0.5, ty: 0.5 };

        let isSnapped = false;

        // Initialization
        function resize() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            width = canvas.width;
            height = canvas.height;

            // Set A and B fixed positions (closer to center, ~35% and 65%)
            A = { x: width * 0.35, y: height * 0.55 };
            B = { x: width * 0.65, y: height * 0.45 };

            draw();
        }

        window.addEventListener('resize', resize);

        // Math Helpers
        function getVector(p1, p2) {
            return { x: p2.x - p1.x, y: p2.y - p1.y };
        }

        function getPointFromParams(tx, ty) {
            const u = getVector(A, B);
            return {
                x: A.x + tx * u.x,
                y: A.y + ty * u.y
            };
        }

        function getParamsFromPoint(x, y) {
            const u = getVector(A, B);
            const tx = Math.abs(u.x) > 0.001 ? (x - A.x) / u.x : 0;
            const ty = Math.abs(u.y) > 0.001 ? (y - A.y) / u.y : 0;
            return { tx, ty };
        }

        function updateDisplay(M_coords) {
            const dispTx = M_params.tx.toFixed(2);
            const dispTy = M_params.ty.toFixed(2);

            // Styling variables in the formula
            let html = `Mx = Ax + <span style="color:#d4af37; font-weight:bold">${dispTx}</span> * (Bx - Ax)<br>`;
            html += `My = Ay + <span style="color:#e08e9d; font-weight:bold">${dispTy}</span> * (By - Ay)`;

            if (isSnapped) {
                html += '<br><span style="color:#50c878; font-weight:bold; letter-spacing: 1px;">✨ YOU BELONG WITH ME (ON THE LINE) ✨</span>';
                infoDisplay.style.borderColor = "#50c878";
                infoDisplay.style.backgroundColor = "rgba(80, 200, 120, 0.1)";
            } else {
                infoDisplay.style.borderColor = "rgba(255,255,255,0.8)";
                infoDisplay.style.backgroundColor = "rgba(255, 255, 255, 0.6)";
            }
            infoDisplay.innerHTML = html;
        }

        function drawStats(M) {
            const boxWidth = 240;
            const boxHeight = 110;
            const x = 20;
            const y = 20;

            ctx.save();
            // Glass effect box
            ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
            ctx.shadowColor = "rgba(0,0,0,0.1)";
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.roundRect(x, y, boxWidth, boxHeight, 15);
            ctx.fill();

            // Border
            ctx.strokeStyle = "rgba(255,255,255,0.8)";
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.shadowColor = "transparent";
            ctx.font = "14px 'Playfair Display'";
            ctx.textAlign = "left";
            ctx.textBaseline = "middle";

            const coords = [
                { label: "A", p: A, color: "#8b5a2b" }, // Dark Rose Gold
                { label: "B", p: B, color: "#8b5a2b" },
                { label: "M", p: M, color: isSnapped ? "#50c878" : "#d4af37" }
            ];

            coords.forEach((item, index) => {
                ctx.fillStyle = item.color;
                ctx.fillText(`${item.label} = (${Math.round(item.p.x)}, ${Math.round(item.p.y)})`, x + 20, y + 25 + index * 30);
            });
            ctx.restore();
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);

            // Draw Line AB (Soft Glow)
            ctx.save();
            ctx.beginPath();
            const u = getVector(A, B);

            ctx.shadowColor = "rgba(255, 255, 255, 0.8)";
            ctx.shadowBlur = 10;
            ctx.strokeStyle = isSnapped ? "#50c878" : "#fff";
            ctx.lineWidth = isSnapped ? 4 : 2;

            // Draw segment AB extended slightly? No, infinite line is not drawn, just the segment or full line?
            // Previous code drew a long line. Let's keep that.
            ctx.moveTo(A.x - u.x * 10, A.y - u.y * 10);
            ctx.lineTo(B.x + u.x * 10, B.y + u.y * 10);
            ctx.stroke();
            ctx.restore();

            // Draw A and B
            drawPoint(A, "A", "#e08e9d"); // Rose
            drawPoint(B, "B", "#e08e9d");

            const uVec = getVector(A, B);
            let rawM = getPointFromParams(M_params.tx, M_params.ty);

            // Snap Logic
            const num = Math.abs(uVec.x * (A.y - rawM.y) - (A.x - rawM.x) * uVec.y);
            const den = Math.sqrt(uVec.x**2 + uVec.y**2);
            const dist = num / den;

            isSnapped = dist < 20;

            let M = rawM;
            if (isSnapped) {
                const t = ((rawM.x - A.x) * uVec.x + (rawM.y - A.y) * uVec.y) / (uVec.x**2 + uVec.y**2);
                M = {
                    x: A.x + t * uVec.x,
                    y: A.y + t * uVec.y
                };
            }

            const displayParams = getParamsFromPoint(M.x, M.y);

            // Draw Vector AM
            drawArrow(A, M, "#fff", 2);

            // Draw Projections
            drawProjection(A, "A", "#e08e9d");
            drawProjection(B, "B", "#e08e9d");
            drawProjection(M, "M", isSnapped ? "#50c878" : "#d4af37");

            // Draw M
            drawPoint(M, "M", isSnapped ? "#50c878" : "#d4af37", true); // Gold or Green

            const originalParams = M_params;
            M_params = displayParams;
            updateDisplay(M);
            M_params = originalParams;

            drawStats(M);
        }

        function drawProjection(p, label, color) {
            ctx.save();
            ctx.setLineDash([4, 4]);
            ctx.strokeStyle = color;
            ctx.globalAlpha = 0.6;
            ctx.lineWidth = 1;

            // Project to X axis
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x, 0);
            ctx.stroke();

            // Label X
            ctx.fillStyle = color;
            ctx.font = "italic 12px 'Lato'";
            ctx.fillText(label + "x", p.x - 8, 15);

            // Project to Y axis
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(0, p.y);
            ctx.stroke();

            // Label Y
            ctx.fillText(label + "y", 5, p.y - 5);

            ctx.restore();
        }

        function drawArrow(from, to, color, width) {
            const headlen = 12;
            const angle = Math.atan2(to.y - from.y, to.x - from.x);

            ctx.save();
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = width;
            ctx.lineCap = "round";

            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.stroke();

            // Elegant thin arrowhead
            ctx.beginPath();
            ctx.moveTo(to.x, to.y);
            ctx.lineTo(to.x - headlen * Math.cos(angle - Math.PI / 8), to.y - headlen * Math.sin(angle - Math.PI / 8));
            ctx.lineTo(to.x - headlen * Math.cos(angle + Math.PI / 8), to.y - headlen * Math.sin(angle + Math.PI / 8));
            ctx.lineTo(to.x, to.y);
            ctx.fill();
            ctx.restore();
        }

        function drawPoint(p, label, color, isM = false) {
            ctx.save();
            ctx.fillStyle = color;
            const size = isM ? 8 : 5;

            // Draw Circle
            ctx.beginPath();
            ctx.arc(p.x, p.y, size, 0, 2 * Math.PI);
            ctx.fill();

            // Glow/Border
            ctx.strokeStyle = "white";
            ctx.lineWidth = 2;
            ctx.stroke();

            if (isM) {
                // Sparkle effect for M
                ctx.shadowColor = color;
                ctx.shadowBlur = 10;
                ctx.stroke();
            }

            // Label
            ctx.font = "bold 16px 'Playfair Display'";
            ctx.fillStyle = "#4a4a4a"; // Dark text for contrast against pastel
            // Add a white halo for readability
            ctx.strokeStyle = "rgba(255,255,255,0.8)";
            ctx.lineWidth = 3;
            ctx.strokeText(label, p.x + 12, p.y - 12);
            ctx.fillText(label, p.x + 12, p.y - 12);

            ctx.restore();
        }

        // Interaction (Same logic)
        function handleInput(x, y) {
            const uVec = getVector(A, B);
            const num = Math.abs(uVec.x * (A.y - y) - (A.x - x) * uVec.y);
            const den = Math.sqrt(uVec.x**2 + uVec.y**2);
            const dist = num / den;

            let params = getParamsFromPoint(x, y);

            if (dist < 20) {
                const t = ((x - A.x) * uVec.x + (y - A.y) * uVec.y) / (uVec.x**2 + uVec.y**2);
                params = { tx: t, ty: t };
            }

            M_params = params;
            draw();
        }

        let isDragging = false;

        function onPointerDown(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || e.touches[0].clientX) - rect.left;
            const y = (e.clientY || e.touches[0].clientY) - rect.top;
            isDragging = true;
            handleInput(x, y);
        }

        function onPointerMove(e) {
            if (!isDragging) return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || e.touches[0].clientX) - rect.left;
            const y = (e.clientY || e.touches[0].clientY) - rect.top;
            handleInput(x, y);
        }

        function onPointerUp() {
            isDragging = false;
            if (isSnapped) {
                draw();
            }
        }

        canvas.addEventListener('mousedown', onPointerDown);
        canvas.addEventListener('mousemove', onPointerMove);
        window.addEventListener('mouseup', onPointerUp);

        canvas.addEventListener('touchstart', onPointerDown, {passive: false});
        canvas.addEventListener('touchmove', onPointerMove, {passive: false});
        window.addEventListener('touchend', onPointerUp);

        function adjust(param, delta) {
            M_params[param] += delta;
            M_params[param] = Math.round(M_params[param] * 10) / 10;
            draw();
        }

        document.getElementById('tx-minus').addEventListener('click', () => adjust('tx', -0.1));
        document.getElementById('tx-plus').addEventListener('click', () => adjust('tx', 0.1));
        document.getElementById('ty-minus').addEventListener('click', () => adjust('ty', -0.1));
        document.getElementById('ty-plus').addEventListener('click', () => adjust('ty', 0.1));

        setTimeout(resize, 100);
    </script>
</body>
</html>
